<html>
<head>
    <style type="text/css">
        .style1
        {
            color: #660033;
        }
    </style>
</head>
<body lang=EN-US>

<h2>PerfMonitor User Guide </h2>

<h3>What is PerfMonitor? </h3>

    <p>PerfMonitor is a tool for collecting and accessing windows tracing 
        information (also known as 
        <a href="http://msdn2.microsoft.com/en-us/library/aa363787.aspx">Event Tracing for Windows
        </a>or ETW). Built into many parts of 
        windows including the kernel and the .NET Common Language Runtime (CLR) are logging routines that will 
        generate very detailed information about what the computer is doing. PerfMonitor 
        is a tool that allows you to turn this logging on (on a machine wide basis) and collect the 
        data into Event Trace Log (ETL) files. PerfMonitor also allows you to convert 
        the binary ETL files to an XML file.</p>
    <h3>Quick Start</h3>
    <p>Perhaps the fastest way to get a sence of the kind of data that is available 
        using PerfMonitor is to quickly collect some.&nbsp;&nbsp; Try the command</p>
    <dl>
        <dd>
            perfMonitor runPrint <span class="style1">perfMonitor list</span></dd>
    </dl>
    <p>
        This command tells perfMonitor to</p>
    <ul>
        <li>Turn on event monitoring (by default for OS event and .NET Common Language 
            Runtime (CLR)).&nbsp; By default this goes to two files call 
            perfMonitorOutput.etl and perfMonitorOutput.kernel.etl.&nbsp; </li>
        <li>Run a command for which you want to collect data.&nbsp; In this case we use the 
            command &#39;perfMonitor list&#39;.&nbsp; </li>
        <li>Turn off event monitoring.</li>
        <li>&#39;Print&#39; the data from the binary *.etl files in a way that can be read by 
            humans.&nbsp; By default this goes into a file called perfMonitorOutput.xml.</li>
    </ul>
    <p>
        You can then browse the data using a text editor, or an XML viewer.&nbsp; 
        Because the XML files tend to be very large, a viewer like XMLView.exe which can 
        handle very large files with ease.&nbsp;&nbsp; By browsing the file you will see 
        the wealth of detailed information that was collected including</p>
    <ul>
        <li>Every process active or was created in the system (including those started 
            before logging began!), including the command line (VISTA only) which started it 
            and the exit code (if it ended). </li>
        <li>Every thread that was active or created in the system.&nbsp; </li>
        <li>Every DLL or EXE that was loaded into some process, and where it lives in the 
            address space of the process that loaded it. </li>
        <li>Every Disk read or write that happened, including its size the the file name 
            associated with it.</li>
        <li>Every page fault in the system, </li>
        <li>A sample of the instruction pointer (IP) every millisecond.&nbsp; Coupled with 
            the DLL load information this tells you where the CPU is spending its time.&nbsp;
        </li>
        <li>Every Garbage Colleciton the CLR performed, when it started and ended, and 
            statistics about how much memory was reclaimed.</li>
        <li>The memory extent of the native code generated by the CLR.&nbsp; This allows the 
            instruction pointers samples to be mapped to the symbolic name of the method 
            that was running (CLR V2.0 SP2 
            only).</li>
    </ul>
    <p>
        In short, if you want detailed data on what your computer is doing, ETW can give 
        it to you.&nbsp;
    </p>
<h3>
    What is Event Tracing for Windows (ETW)?</h3>
<p>
    <a href="http://msdn2.microsoft.com/en-us/library/aa363787.aspx">Event Tracing for Windows</a> 
    (ETW) is a machine wide, light weight, general purpose, extensible logging 
    mechanism built into the Windows operating system since Windows 2000.&nbsp;&nbsp; 
    The basic architecture defines the following components </p>
<ul>
    <li><b>Providers</b>.&nbsp;&nbsp; A provider is a component that wishes to log data.&nbsp;&nbsp; 
        Each provider defines for itself a <a href="http://it.wikipedia.org/wiki/GUID">
        GUID</a> which uniquely identifies itself to the ETW system.&nbsp; Two very 
        important providers are the OS Kernel, and the .NET CLR, however there are 
        literally hundreds of providers already defined in windows, and applications are 
        free to create their own (In managed code you do so through 
        System.Diagnostics.Eventing.EventProvider)&nbsp; When a 
        provider starts up, it registers its GUID with the ETW system to indicate that 
        it is available.&nbsp;&nbsp; A provider will not actually log data yet, but the 
        registration includes a callback that allows the ETW system to turn the provider 
        on and off (selectively).</li>
    <li>&nbsp; <b>Controlers</b>.&nbsp; A controler is an application that wishes to 
        collect ETW data.&nbsp; PerfMonitor is an example of a&nbsp; ETW controller.&nbsp;&nbsp;
    </li>
    <li><b>Sessions</b>.&nbsp; A session represents a set of &#39;turne.&nbsp; A session represents a set of &#39;turned on&#39; providers.&nbsp;&nbsp; 
            To turn on a provider, a controller must first create a session, and then enable 
            providers (identified by their GUID) in that session.&nbsp;&nbsp; This allows 
            the controller to pick and choose the information that is colleced.&nbsp; In 
            adidtion to selecting which providers to turn on, it also allows a set of flags 
            to be passed that will tell the provider which subsystems the controler is 
            interested in as well as well as the verbosity level.&nbsp;&nbsp; When a 
            provider is added to a session, the ETW system issues a callback to the provider 
            with this information and the provider starts logging messags.&nbsp;&nbsp; 
            Sessions are machine wide, and outlive the process that created them.&nbsp;&nbsp; 
            When providers are turned on they are also turned on machine wide.&nbsp; For 
            example Common Language Runtime (CLR) is a provider that may exist in many 
            processes (and have registered themselves with the ETW system.&nbsp; When an ETW 
            controller enables the CLR providers in all existing processes, and will enable 
            any new processes that start up a CLR (when the CLR registers itself).&nbsp; It 
            is currently&nbsp; not possible to scope logging to a particular process 
            instance.&nbsp; The session will remain on even if the controller&#39;s process 
            dies.&nbsp; Only by explictly disabling a provider or closing the session (or 
            machine reboot) will stop the logging.&nbsp;&nbsp; Thus it is important that 
            controllers take extra care to insure that they to no leave sessions running 
            inadvertantly.&nbsp; </li>
        <li><b>Events</b>..&nbsp; When providers get the callback to enable them, they 
            activate the requested logging events (taking into account the subsystem flags 
            and verbosity level).&nbsp;&nbsp; These events are sent to the Session, which is 
            responsible for either forwarding them to the Controler (a so call &#39;real time&#39; 
            session), or logging them to a file (typically called a Event Trace Log or .ETL 
            file).&nbsp;&nbsp; Each event has the following items
            <ul><li>A high resolution (100ns) timestamp.&nbsp;&nbsp; Because 
                it is sometimes important to know the exact ordering of events from different 
                subsystems (being logged by different processors) some trouble has been taken to 
                synchronize the clocks used by different processors so that events can be 
                correctly ordered even if the time interval between events is very small. </li>
            <li>The process and thread ID where the event was logged.&nbsp;&nbsp; Note that some 
                OS kernel events leave these fields undefined because there is no obvious 
                process and thread to associate with the event being logged. /li>
            <li>An <a href="http://it.wikipedia.org/wiki/GUID">
        GUID</a>  that identifies the logical system the event is associated with.&nbsp;&nbsp; 
                For example the CLR has an event GUID that is used for all events associatd with 
                the garbage collector (GC), and another for events associated with its thread 
                pool.&nbsp; </li>
            <li>An small number called an opcode which represents a specific type of messaged 
                being logged.&nbsp; 
                For example, the CLR has opcode for when a garbage collection starts, and  another when it ends, one when it enlarges the heap, and one that fires every 
                time approximately 100K of object have been allocated.&nbsp;&nbsp; All of these 
                mesages sare the same event GUID (indicating the GC subsystem), but have 
                different opcodes.&nbsp; 
                </li>
            <li>Event specific data.&nbsp;&nbsp; The event GUID coupled with the opcode define 
                structure of the rest of the data.&nbsp;&nbsp; For example, a GC Start event 
                gives the number of GCs that have happened previously, as well as an enumeration 
                that indicates why this GC happened (need memory, explict call ...). A GC End 
                event has numerous statistics about what happened during the GC.&nbsp;&nbsp; The 
                fact that events can have strongly typed, event-specific data, is a key feature 
                of the ETW architecture that makes it exceptionally valuable.&nbsp;&nbsp;&nbsp; 
                </li>
        </ul>
            </li>
    </ul>


<p>
    For more information there is a good
    <a href="http://msdn.microsoft.com/msdnmag/issues/07/04/ETW/">MSDN article</a> 
    that talks more about Event Tracing for Windows.&nbsp;
</p>


<h3>
    Using PerfMonitor to colUsing PerfMonitor to collect data</h3>
<p>
    As mentioned previously, one of major functions of PerfMonitor is to provide a 
    mechanism for users to conrol the collection of ETW data by acting as an ETW 
    Controller.&nbsp;&nbsp; This is exposed in the following PerfMonitor commands</p>
<ul>
    <li>perfMonitor [<i>options</i>] start [<i>&lt;fileName&gt;</i>]</li>
    <li>perfMonitor [<i>options</i>] stop</li>
</ul>
<p>
&nbsp;The start command turns on (machine wide) logging, and the stop command turns 
    logging off.&nbsp;&nbsp;&nbsp; Only one session can be on simultaneously.&nbsp; 
    If you try to start a session when one is already started, it closes the 
    existing session and opens an new one.&nbsp;&nbsp; The effect of turning on a 
    session is immediate and take effect on live processes as well as new processes 
    that are created.&nbsp; A filename can be specifed (suggested extention is 
    .ETL), but it will default to &#39;perfMonitorOutput.etl if not provided.&nbsp; ETW 
    allows a huge array of events to be turned on, which can be a daunting task, so 
    perfMonitor simplifies this&nbsp; by choosing a good set of default events, that 
    are useful in a broad variety of performance invesigations but are not too 
    expensive to collect.&nbsp;&nbsp; This includes OS kernel operations associated 
    with processes, threads, DLLs, page faults, diskIO, and CPU sampling as well as 
    CLR events associted with Garbage Collections, the CLR Thread pool, lock 
    contention, exceptions, and compilation of managed code to native code.&nbsp;&nbsp;
</p>
<p>
    Due to a limitation in implementation, kernel event can not be collected into 
    the same ETL file as all other events.&nbsp;&nbsp; PerfMonitor works around this 
    by making two separate files (eg *.etl and *.kernel.etl).&nbsp;&nbsp; Whenver it 
    is manipuating etl files, it looks for the *.kernel.etl &#39;shadow&#39; file and 
    combines the two files into one when doing its processing.&nbsp;&nbsp;&nbsp; 
    Thus typically perfMonitor generates two files.&nbsp;&nbsp; </p>
<p>
    PerfMonitor supports the following options for fine tuning the data collected</p>
<ul>
    <li>/noKernel - Don&#39;t collect OS kernel events (just the CLR events).&nbsp; For 
        example if you were only interested in GC statistics you might use this option</li>
    <li>/noCLR - Don&#39;t collect .NET CLR Runtime events.&nbsp;&nbsp; If the process you 
        are interested in is not managed, but there are other managed processes running, 
        you can use this to avoid collecting events from uninteresting processes.&nbsp;
    </li>
    <li>/provider:<b><i>guid</i></b>:<b><i>flags</i></b>:<b><i>level</i></b> this option 
        allows you to turn on any arbitrary event provider by specifying its GUID, and 
        pass that provider a set of flags and the logging level.&nbsp;
        <ul>
        <li>The GUID can be any string that can be passed to the System.<a 
                href="http://msdn2.microsoft.com/en-us/library/aa328604(VS.71).aspx">Guid 
            constructor</a>.&nbsp; It can also be the following speciallly recognised GUIDs
            <ul><li>Clr - This represents the CLR provider.&nbsp; Normally the CLR provider 
                (with good default flags and level settings), is on by default, but by 
                specifying&nbsp; /noClr and explicitly setting /provider:CLR:<b><i>flags</i></b>:<b><i>level</i></b> 
                the user has complete control over the settings.&nbsp; </li>
                        <li>ClrStress - This represents the built in CLR Stress log.&nbsp; This facility 
                            causes text messages to be logged when significant &#39;rare&#39; events happen.&nbsp; 
                            It is intended for debugging failures in the runtime in the field.&nbsp; The 
                            flags field represents the sub-facilities of the CLR (see StressLogFacilities 
                            for defintions). </li></ul></li>
                <li>The flags is an integer value expressed as a hexidecimal number (without any 0x 
                    qualifications).&nbsp; The interpretation of these bits is up to the provider, 
                    however typically it is a bit vector that indicates what facilities within the 
                    provider should be turned on.&nbsp; </li>
                <li>The level is an integer that specifies the verbosity of the logging.&nbsp; 0 = 
                    off, 1 = Fatal, 2 = Error, 3 = Warning, 4 =&nbsp; Information, 5 = Verbose.&nbsp; </li>
        </ul>
    </li>
</ul>
<p>
    These options only have an effect if the Kernel provider is turned on (that is 
    /noKernel was NOT specified);</p>
<ul>
    <li>/noProfile - The sample based profiling every 1msec is one of the more common 
        events in the log.&nbsp; You can reduce the log size significantly by turning 
        off this profiling if you are not interested in it.</li>
    <li>/cswitch - The kernel and fire an event every time one thread loses the CPU to 
        another thread (a context switch or cswitch).&nbsp; These events are VERY 
        valuable to understand what is causing delays (because whenever a thread waits, 
        it context switches), but are also quite volumnous (3X more common than sample 
        profile), so they are off by default. </li>
    <li>/stacks&nbsp; - (VISTA only)&nbsp; For kernel OS events, it is possible to ask 
        the kernel to crawl the stack and log that stack trace on every event that it 
        logs.&nbsp; This gives a very useful hierarchical view of where an event occurs.&nbsp;&nbsp; 
        It generally increases the log size by a factor of 5 or more because every event 
        has another stack trace event associated with it (which has up to 96 call frames 
        in it)</li>
</ul>
<p>
    Once started, the ETW session created by &#39;perfMonitor start&#39; will live until it 
    is explictly stopped with &#39;perfMontior stop&#39;.&nbsp; It is relatively easy for a 
    session to be left running accidentially (eg when a script fails and does not 
    call &#39;perfMonitor stop&#39;), so perfmonitor provide the following command</p>
<ul>
    <li>perfMonitor run <i>&lt;command&gt;</i>&nbsp; </li>
</ul>
<p>
    This command starts monitoring, runs a command, and stops monitoring.&nbsp; It 
    has error handling so that in most cases it will not leave monitoring on (eg if 
    you hit Ctrl-C it will stop monitoring before exiting).&nbsp; However if 
    perfMonitor is terminated by an external agent (eg from Task manager), it won&#39;t 
    be able to do this cleanup.&nbsp;&nbsp; Generally it is safer and more 
    convinient to use the run command when you can do so.
</p>
</body>

</html>
